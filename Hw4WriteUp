**Brett Chafin's Hw4 write up**

----------Task 2------------------

***jacc File***

To incorperate for loops into the compiler, the first step was to adjust 
the grammer in the jacc file to recognize them. This is the line i added 
to the stmt block in the grammer

	 FOR '(' initStmt ';' stepStmt ';' stepStmt ')' stmt  {$$ = new For($1, $3, $5, $7, $9);}

To make jacc accecpt this this new line, I first had to create new token for 
the FOR keyword. To do this, I modified the Lexer to recognize to the lexeme 'for',
and then added it to the %token list at the top of the file. 

I also created an assertion for FOR to ensure it was of type Position

	%type <Position> FOR

The initStmt's and stepStmts are the required fields to create a new For class
The stmt at the end corresponds to the block of the for loop. 

The java code {$$ = new For($1, $3, $5, $7, $9); } ensures that the original statement
is passed back as a new For loop object, initilized with all the required fields. 


***For loop Static Analysis***

---Scope Analysis---

Here is the code I implemented to the Scope Analysis function in For.java:

 	  Env env1 = first.analyze(scoping, env);
          test.analyze(scoping, env1);
          body.analyze(scoping, env1);
          step.analyze(scoping, env1);
 	  return env;

My first statement creates a new Env env1 becuase the first statement in a forloop is
allowed to introduce new varibles that the rest of the for loop can use. I passed in
the original envirnment (scoping, env), becuase the for loop has access to the environment
directly before the loop starts.

My second statement, i dont need to to store the retured Env because no new varibles 
should be introduced in the test statement. The same logic applies to my fourth Statement, 
looking at the step statement. All three statements are passed in env1 to incorperate the
new Env created by the 'first' statement. 

The body can introduce new varibles into the environment, but we do not need to save 
the body's Env becuase all new varibles that are introduced within are lost after the 
body is dont exucuting. 

We then return the original Env, being that nothing introduced in the For loops Env will 
make it past the last curly brace of the loops body. 


---Type Analysis---

Here is the code I implemented to the TypeAnalysis function in For.java

 	 first.analyze(typing);
         test.require(typing, Type.BOOLEAN);
         body.analyze(typing);
         step.analyze(typing); 

The analyze calls are all very strait forward, and make sure that the types match up 
in each of the statements

For the test statement, I needed to implement the require function, which makes sure that
the statement in the test evaluated to a boolean value. 
To do this, I added an abstract method to the StepStmt class: 

	public abstract class StepStmt extends InitStmt {
  
        	abstract void require(TypeAnalysis typing, Type type);
 	}

I then had to implement the required function in both the ExprStmt class, and the Empty
class. 

In the ExprStmt Class: 

	public void require(TypeAnalysis typing, Type expectedType) {
          
            expr.require(typing, expectedType);
	}

This invokes a require method already created in the expr class, which will throw an 
error if the type does not match the expectedType. 

In the Empty class:

	public void require(TypeAnalysis typing, Type type) {
 
          return;
      	}	

If there is no statement, then we dont have to do anything. 


---InitAnalysis---

Here in the code I implemented for the InitAnalysis analyze function in For.java

 	 VarSet initialized1 = first.analyze(init, initialized);
         test.analyze(init, initialized1);
         VarSet initialized2 = body.analyze(init, initialized1);
         step.analyze(init, initialized1);

	return initialized2;

In the first line of code, we are creating a new VarSet to catch the the varibles that 
could be initilized in the 'first' statement of the for loop, passing in the set of already
initialized varible before the for loop started. 

In the test and step statements, we are not allowed to initialize any varibles, so we do 
not need to catch the VarSets that the analyze function returns. We pass both of these
the new VarSet generated by the 'first' statement. 

The 'body' statement in a for loop has the power to initialize varibles outside of the loop,
so the VarSet created by the body will need to be caught by my new VarSet initialized2.

We return the VarSet that includes all initialization that happed in the 'first' statement, 
as well as any that happened in the body of the loop. 

---Testing---

Below is my forLoop.mini test file

	for(int i = 0;i < 10; i = i + 1) print i;
 
  	for(;;) { }
  	for(int i=0; i<10; ) i = i + 1;
   
  	 int i;
  	 for( i = 0; i < 10; i = i +1) print i;
   
  	 int x;
 	for(int i = 0; i < 10; i = i + 1) {
 	 
 	        x = i;
 	}
 	
 	x = x + 1;

This file compiles with no errors, and tests a variety of different compenents

The first loop is a standard for loop, testing the average case for For loops.
The second loop is aimed to test my jacc grammer, and make sure some edge case
For loop structures are accepted.
The third loop also is aimed to check my grammar. 
The fourth loop checks in scope analysis is working, making the loop use the previous Env
before the loop for the 'first' statement. 
The fifth loop check the Initialization, making sure the the VarSet of the loop is 
usable after the loop ends. 

Where are some tests that fail in the compiler

	for(i = 0; i < 10; i = i + 1) { }
	
An error is thrown in the scope analysis phase, which sees that i has not been
initialized before the loop, so it cannot be used in the 'first' statement. 

	for(boolean i = 0; i < 10; i = i + 1) { } 

An error is thrown in the Type Analysis phase, which sees that boolean i does not
to type int in any of the statements.

	int x;
	int i;  
	for(i = 0; i < 10; i = i + 1) {

		x = x + i; 
	}

An error is thrown in the InitAnalysis phase, which sees that in the body of the 
for loop, x has not been initialized before it is used in the statement 
x = x + i, which means x was not yet in the VarSet. 


----------Task 3------------------

I was only able to complete part of this task, so the description will not quite 
be complete

---jacc file--- 

For array declaration and initilization, I needed to add several new productinons
to the current grammar. The first thing I added was productions that would include 
the new array type. 

 81 type    : INT                           { $$ = Type.INT; }
 82         | BOOLEAN                       { $$ = Type.BOOLEAN; }
 83         | arrayType                     { $$ = $1; }
 84         ;
 85 
 86 arrayType : INT brackets                {$$ = new ArrayType(Type.INT); }
 87           | BOOLEAN brackets            {$$ = new ArrayType(Type.BOOLEAN); }
 88           ;
 89 
 90 brackets : '['  ']'
 91          | '[' ']' '[' ']'
 92          ;

In the java code I create new array types, passing in the required Type paramater
This allowed varDecls such as int[] i; and boolean[] j; . 

Next I tackled the array type declarations. 

stmt -> initStmt ';' -> varDecl ';' -> type varIntro ';' -> type IDENT '=' expr

This meant that i only needed to add a production to expr for the initialization. 
I added the following production arrayInit to the bottom of primary's production.  

149 primary : INTLIT                        { $$ = $1; }
150         | TRUE                          { $$ = new BoolLit($1, true); }
151         | FALSE                         { $$ = new BoolLit($1, false); }
152         | IDENT                         { $$ = $1; }
153         | '(' expr ')'                  { $$ = $2; }
154         | arrayInit                     { $$ = $1; }
155         ; 
156         
157         
158 arrayInit : NEW INT '[' expr ']'        {$$ = new NewArray($1, Type.INT, $4); }
159           | NEW BOOLEAN '[' expr ']'    {$$ = new NewArray($1, Type.BOOLEAN, $4); }
160           ;  

'NEW' needed to be added as a token, with assertion as a Position, and i modiyied the 
lexer to recognize the key word as well. 

The size portion of the array could be any expr that returned an Integer value. 
This new grammer allows for initialization statements like int[] i = new int[5], 
and boolean[] j = new boolean[1+3]; 

---Static Analysis--- 

Here are my analysis functinos for NewArray.java


public void analyze(ScopeAnalysis scoping, Env env) {
 65         
 66         //Makes sure every varible used in size is in the current scope
 67         //expr analyze functions are void, so nothing to catch
 68         size.analyze(scoping, env);
 69      
 70     }
 
public Type analyze(TypeAnalysis typing) {
 82         
 83         //requires that the expr size has an Integer return value
 84         Type type = size.require(typing, Type.INT);
 85         return type;
 86     }

public VarSet analyze(InitAnalysis init, VarSet initialized) {
 99         
100         //Makes sure everything used in the size expr has been initialized 
101         size.analyze(init, initialized);
102         
103         return initialized;
104     }



----------Task 4------------------



